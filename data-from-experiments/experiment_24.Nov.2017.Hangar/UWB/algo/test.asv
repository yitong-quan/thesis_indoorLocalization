%%     
%     pause_time = 0.3*[time_diff; 2];
%     for j = 3:size(X,2) %1:size(X,2)-9 
%         h2 = plot(X(1,j-2:j), X(2,j-2:j), '-ob'); %h2 = plot(X(1,j:j+9), X(2,j:j+9), '-+r'); 
%         h3 = plot(real_X(1,j-2:j), real_X(2,j-2:j), '-ok');
%         str_title = sprintf('experiment%d; factorQ: %d; factorR: %d; j: %d', experimentNumber, factor_Q, factor_R, j);
%         title(str_title);
%         % Fram(j-4) = getframe(gcf);
%         pause(pause_time(j));
%         delete(h2);
%         delete(h3);
%     end
%% mitigation weighted linear combiation
        %% measurement update
        R = R_all;

        Z_e = Z_e_all;
        H_symbolic = H_all_symbolic;
        % remove the measurement data with NaN
        z = z_all(:, i); % measurement data
        k = length(z);
        index_ian = find(~isnan(z)); % is a number
        while k >= 1
            if isnan(z(k)) % if no measurements are coming
                z(k) =[];
                Z_e(k) = [];
                H_symbolic(k,:) = [];
                R(k,:) = []; R(:,k) = [];
            end
            k = k-1;
        end

z_length = length(z);
if z_length <= 3
    z_candidate = z; 
    numCombinations= 1;
else    
    residual_sum_array = [];
    x_estimated_array  = [];
    P_array = [];
    createNaNnum = z_length - 3;
    for nn = 0 : createNaNnum
        idxNaN = 	combnk(1:z_length, nn); % size #combinations * nn
        numCombinations = size(idxNaN,1) ;
        for idxNaN_i = 1:numCombinations % #combinations
            z(idxNaN_i) = nan; % elements with idx all turn into NaN
            k = length(z);
            while k >= 1
                if isnan(z(k)) % if no measurements are coming
                    z(k) =[];
                    Z_e(k) = [];
                    H_symbolic(k,:) = [];
                    R(k,:) = []; R(:,k) = [];
                end
                k = k-1;
            end
            
            H = vpa(eval(subs( subs(H_symbolic, x_m, x_minus), N_x_n, positionOfNodes))); %<<<change!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   
            
            R_ = R * R_affected_by_dt; % adjust R by dt
            R_ = R_ * meas_trust_factor; % adjust R by steps of ignored update due to missing measurements
            
            K_k = P_minus * H' / (H * P_minus * H' + R_); %<<< R_ >change!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            %<<< add Z_e >change!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            residual = z - eval(subs( subs(Z_e, x_m, x_minus), N_x_n, positionOfNodes)); % <<<<<<wikipedia<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            residual_sum = sum(residual);
            residual_sum_array = [residual_sum_array, residual_sum];
            x_estimated = x_minus + K_k * (residual); % <<<<<<wikipedia<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            x_estimated_array = [x_estimated_array, x_estimated];
            P_array = [P_array, P];
        end
                    
            %K(:, :, i) = K_k;
            residual_sum_array
            X(:, i) = x_estimated_array .* inv(residual_sum_array) /  ;
            
            P(:, :, i) = vpa((eye(length(x_0)) - K_k * H) * P_minus);
    end
end    